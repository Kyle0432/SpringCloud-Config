  #网关的大致流程意思是 我现在服务网关9527挡在服务8001前面
  #如果我们现在要访问服务8001的/payment/get/31接口,要先通过
  #服务9527网关,在网关里面需要配置上去,然后断言,路径相匹配的进行路由到你所访问的服务
  #网关可以认为是一个帮你转发请求的一个处理器
  #添加网关前  http://localhost:8001/payment/get/31
  #添加网关后 http://localhost:9527/payment/get/31
  #表示通过服务网关9527能访问到8001地址,然后判断8001下面是否有/payment/get/**
  #也就是9527后面的路径(/payment/get/31)是否能匹配8001下面的/payment/get/**这个地址 有的话直接路由到改地址
  #这样就不需要暴露我们的服务端口了,直接统一调用我们的服务网关来实现路由到具体的请求接口地址,这样就比较安全,
  #而且统一了调用网关端口,客户端不需要多次调用不同的端口服务

  #微服务网关概述
  #不同的微服务一般会有不同的网络地址，而外部客户端可能需要调用多个服务的接口才能完成一个业务需求，
  #如果让客户端直接与各个微服务通信，会有以下的问题：
  #客户端会多次请求不同的微服务，增加了客户端的复杂性
  #存在跨域请求，在一定场景下处理相对复杂
  #认证复杂，每个服务都需要独立认证
  #难以重构，随着项目的迭代，可能需要重新划分微服务。例如，可能将多个服务合并成一个或者将一个服务拆分成多个。如果客户端直接与微服务通信，那么重构将会很难实施
  #某些微服务可能使用了防火墙 / 浏览器不友好的协议，直接访问会有一定的困难
  #以上这些问题可以借助网关解决。
  #网关是介于客户端和服务器端之间的中间层，所有的外部请求都会先经过 网关这一层。
  #也就是说，API 的实现方面更多的考虑业务逻辑，而安全、性能、监控可以交由 网关来做，这样既提高业务灵活性又不缺安全性

  #优点如下：
  #安全 ，只有网关系统对外进行暴露，微服务可以隐藏在内网，通过防火墙保护。
  #易于监控。可以在网关收集监控数据并将其推送到外部系统进行分析。
  #易于认证。可以在网关上进行认证，然后再将请求转发到后端的微服务，而无须在每个微服务中进行认证。
  #减少了客户端与各个微服务之间的交互次数
  #易于统一鉴权。
  #总结：微服务网关就是一个系统，通过暴露该微服务网关系统，方便我们进行相关的鉴权，安全控制，日志统一处理，易于监控的相关功能。

  #网关（API Gateway）的设计要素
  #限流：实现微服务访问流量计算，基于流量计算分析进行限流，可以定义多种限流规则。
  #缓存：数据缓存。
  #日志：日志记录。
  #监控：记录请求响应数据，api耗时分析，性能监控。
  #鉴权：权限身份认证。
  #灰度：线上灰度部署，可以减小风险。
  #路由：路由是API网关很核心的模块功能，此模块实现根据请求，锁定目标微服务并将请求进行转发

  #系统级别:
  #高可用性
  #均衡负载: 容错,防止雪崩.
  #并发控制 : 错峰流控
  #动态路由制定和修改


#gateway有两种网关路由配置的方式: 以下是是第一种在yml中进行配置
server:
  port: 9527  #网关端口
spring:
  application:
    name: cloud-gateway  #网关也是一个微服务  微服务名称
  cloud:
    gateway:
      discovery:
        locator:
          enabled: true #开启从注册中心动态创建路由的功能,利用微服务名进行路由
      routes: # 网关路由这里是多个,说明某个controller里面所有rest接口都可以做路由
        - id: payment_routh #路由的ID，没有固定规则但要求唯一，建议配合服务名
          #uri: http://localhost:8001 #匹配后提供服务的路由地址,不过这样的地址是写死的,
          #因为如果服务进行扩容也就是集群有8001到8005就不能写很多个,所以需要动态路由以微服务名来路由,
          #因为如果是集群所有服务都是在某个微服务名下的
          uri: lb://cloud-payment-service #需要注意的是uri的协议为lb，表示启用Gateway的负载均衡功能。
          predicates: #断言   注意这里的uri和predicates相互拼接起来就是接口地址,这里的**表示的是通配符
            - Path=/payment/get/** #断言,路径相匹配的进行路由
        - id: payment_routh2
          #uri: http://localhost:8001
          uri: lb://cloud-payment-service
          predicates:
            - Path=/payment/lb/** #断言,路径相匹配的进行路由
            #其实断言有很多种属性,就好比写sql一样where后面可以有很多关键字条件 比如 in orderBy or and 等等
            #After这个表示在这个时间之后我们访问path这个路径才有用,Before和Between一样只不过是Between要写两个第一个就是开始时间第二个截止时间
            - After=2020-10-06T15:50:25.173+08:00[Asia/Shanghai]
            #表示的是只有发送的是get请求才path才起效
            - Method=GET
            - Query=username, \d+  #表示的是查询条件参数名称要为username并且值要为正数才能进行路由
eureka:
  instance:
    hostname: cloud-gateway-service
  client: #服务提供者provider注册进eureka服务列表
    service-url:
      register-with-eureka: true
      fetch-registry: true
      defaultZone: http://eureka7001.com:7001/eureka

